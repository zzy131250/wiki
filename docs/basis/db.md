# 数据库
## B 树索引 vs B+ 树索引
- 相同点：解决主存与磁盘速度差异，用更多的计算减少磁盘访问，减小树的深度
- 不同点：B+ 树解决了 B 树在提高了磁盘 IO 性能的同时并没有解决元素遍历的效率低下的问题

## LSM 索引
- 输入的数据会被先存在日志文件中，这些文件内的数据是完全有序的，当文件被修改时，对应的更新会被先保存在内存中，这样可以加速查询。LSM树分为两个部分，一部分在磁盘一部分在内存，当内存空间逐渐被占满之后，LSM会把这些有序的键刷新到磁盘，同时和磁盘中的LSM树合并成一个文件
- 通过磁盘顺序写来达到最优的写性能，但是降低了读性能

## 数据库事务原理
![](http://osbdeld5c.bkt.clouddn.com/18-3-31/1597284.jpg)

## Mysql InnoDB vs MyIASM
- MyIASM 是非事务安全的，而 InnoDB 是事务安全的
- MyIASM 锁的粒度是表级的，而 InnoDB 支持行级锁
- MyIASM 支持全文类型索引，而 InnoDB 不支持全文索引
- MyIASM 相对简单，效率上要优于 InnoDB，小型应用可以考虑使用 MyIASM

## 数据库主从同步对比
![](http://osbdeld5c.bkt.clouddn.com/18-3-31/16674531.jpg)

## Copy-On-Write vs MVCC
- Copy-On-Write：在写入时新建一个块，写入新块中，再替换原有块；适合读多写少的情景，满足最终一致性
- MVCC：类似于 Copy-On-Write，当有读事务访问一个旧值时，修改类事务就会 copy 出来一个副本进行修改，保证读写不会冲突，而且不会锁住流程

## 数据一致性
### 主从数据库一致性
- 写请求在主从数据库同步之后再返回；会增加延时
- 数据库中间件，CUD路由到主库，并记录key；在R时，如果在经验主从同步时间窗口内，则路由到主库，否则路由到从库
- 使用cache替代中间件，一样的操作，但是成本较低

### 数据库缓存一致性（缓存读取与更新）
- 首先尝试从缓存读取，读到数据则直接返回；如果读不到，就读数据库，并将数据会写到缓存，并返回
- 更新数据
 - 先更新数据库，然后把缓存里对应的数据失效掉（删掉）；会有一小段时间的不一致，可设置过期时间，经常更新
 - 先更新缓存，再同步到数据库；读缓存无数据，然后读数据库，在准备写到缓存时，写线程更新了缓存，此时读线程会把旧数据覆盖到缓存，可维护数据版本，读线程更新缓存时，发现版本不一致则停止更新缓存

### 分布式缓存一致性
- 分布式缓存可以丢失，但是不能出错，对于新增的缓存，可以不同步；删除、修改的缓存，可以通知其他缓存直接删除对应数据
- 通过 zookeeper 锁实现一致性
- redis 使用一致性 hash，只需一份缓存

## 如何避免缓存穿透
- 缓存空对象：对查询结果为空的对象也进行缓存；适合命中率不高，但可能被频繁更新的数据
- 单独过滤处理：对所有可能对应数据为空的key进行统一的存放，并在请求前做拦截；适合命中不高，但是更新不频繁的数据