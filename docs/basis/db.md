# 数据库
## 聚集索引 vs 非聚集索引
- 聚集索引：索引的逻辑顺序决定数据的物理顺序
- 非聚集索引：索引的逻辑顺序与数据的物理顺序不同

## 覆盖索引
索引表包含满足查询的所有数据，不必回查数据表

## B 树索引 vs B+ 树索引
- 相同点：解决主存与磁盘速度差异，用更多的计算减少磁盘访问，减小树的深度
- 不同点：B+ 树解决了 B 树在提高了磁盘 IO 性能的同时并没有解决元素遍历的效率低下的问题

## 数据库事务性质（ACID）
- 原子性：事务的更新操作必须作为一个整体，要么全部成功完成，要么全部失败
- 一致性：事务的成功完成将数据库从一个一致状态转变到另一个一致状态
- 隔离性：即使多个事务并发执行，看上去要像每个成功事务按串行调度执行一样
- 持久性：一旦事务提交，那么它对数据所作的修改将是持久的，无论发生何种机器和系统故障

## 数据库事务隔离级别原理
![](http://osbdeld5c.bkt.clouddn.com/18-3-31/1597284.jpg)

## 数据库主从同步对比
![](http://osbdeld5c.bkt.clouddn.com/18-3-31/16674531.jpg)

## Copy-On-Write vs MVCC
- Copy-On-Write：在写入时新建一个块，写入新块中，再替换原有块；适合读多写少的情景，满足最终一致性
- MVCC：数据库的乐观锁实现，类似于 Copy-On-Write，当有读事务访问一个旧值时，修改类事务就会 copy 出来一个副本进行修改，保证读写不会冲突，而且不会锁住流程

## Mysql InnoDB vs MyIASM
- MyIASM 是非事务安全的，而 InnoDB 是事务安全的
- MyIASM 锁的粒度是表级的，而 InnoDB 支持行级锁
- MyIASM 支持全文类型索引，而 InnoDB 不支持全文索引
- MyIASM 相对简单，效率上要优于 InnoDB，小型应用可以考虑使用 MyIASM

## Mysql InnoDB 锁
- 表锁
 - 读锁：LOCK TABLE table READ；用读锁锁表，会阻塞其他事务修改表数据
 - 写锁：LOCK TABLE table WRITE；用写锁锁表，会阻塞其他事务读和写
- 行锁
 - 共享锁：一个事务对一行的共享只读锁。SELECT ... LOCK IN SHARE MODE;
 - 排它锁：一个事务对一行的排他读写锁。SELECT ... FOR UPDATE;
- 意向锁：在加行锁之前，先加表意向锁。之后其他事务想要申请表锁时，不用遍历每行查看是否有行锁

## Mysql InnoDB 可重复读级别可以避免某些幻读
### 快照读 vs 当前读
- 快照读：读各个事务独立的数据，但不一定是最新数据
- 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前最新的数据

### 避免范围幻读
- 通过 MVCC 避免快照读的幻读
 - 在 undo log 中记录事务版本号，各个事务都读取对应版本的数据
- 通过 Next-Key 锁避免当前读的范围幻读

#### Next-Key 锁
Next-Key 锁是行锁和 GAP （间隙锁）的合并。行锁防止别的事务修改或删除，GAP 锁防止别的事务新增

#### GAP 间隙锁
事务更新某条数据时，在该行加入行锁，同时在两边的区间加上 GAP 锁，如果使用的是没有索引的字段，那么会给全表加入 GAP 锁

## 数据一致性
### 主从数据库一致性
- 写请求在主从数据库同步之后再返回；会增加延时
- 数据库中间件，CUD路由到主库，并记录key；在R时，如果在经验主从同步时间窗口内，则路由到主库，否则路由到从库
- 使用cache替代中间件，一样的操作，但是成本较低

### 数据库缓存一致性（缓存读取与更新）
- 首先尝试从缓存读取，读到数据则直接返回；如果读不到，就读数据库，并将数据会写到缓存，并返回
- 更新数据
 - 先更新数据库，然后把缓存里对应的数据失效掉（删掉）；会有一小段时间的不一致，可设置过期时间，经常更新
 - 先更新缓存，再同步到数据库；读缓存无数据，然后读数据库，在准备写到缓存时，写线程更新了缓存，此时读线程会把旧数据覆盖到缓存，可维护数据版本，读线程更新缓存时，发现版本不一致则停止更新缓存

### 分布式缓存一致性
- 分布式缓存可以丢失，但是不能出错，对于新增的缓存，可以不同步；删除、修改的缓存，可以通知其他缓存直接删除对应数据
- 通过 zookeeper 锁实现一致性
- redis 使用一致性 hash，只需一份缓存

## 分布式锁实现
### 利用

## 如何避免缓存穿透
- 缓存空对象：对查询结果为空的对象也进行缓存；适合命中率不高，但可能被频繁更新的数据
- 单独过滤处理：对所有可能对应数据为空的key进行统一的存放，并在请求前做拦截；适合命中不高，但是更新不频繁的数据