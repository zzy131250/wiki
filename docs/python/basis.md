# 基础
## 生成器
生成器是迭代器的一种，以更优雅的方式实现的迭代器，其中含有 yield 关键字。

## 变量作用域（搜索顺序）
本地作用域（Local）→ 当前作用域被嵌入的本地作用域（Enclosing locals）→ 全局/模块作用域（Global）→ 内置作用域（Built-in）

## is vs ==
is 对比地址，== 对比值

## range vs xrange
range 返回 list，xrange 返回惰性计算的序列对象

## staticmethod vs classmethod
### staticmethod
- 函数既不与类绑定，也不与对象绑定

### classmethod
- 第一个参数是 cls
- 模拟 java 中的多个构造函数
- 函数与类绑定

## 下划线
- \_\_foo\_\_：一种约定，表示 python 内部函数，区别于用户自定义函数
- \_foo：一种约定，指定变量为保护成员，不能用 from module import \* 导入，其他和公有成员一样
- \_\_foo：私有成员，解析器用 \_classname\_\_foo 来代替这个名字，以区别和其他类相同的命名，它无法直接像公有成员一样随便访问，必须通过 对象名.\_类名\_\_xxx 的方式访问

## object 对象的方法
### \_\_new\_\_ vs \_\_init\_\_
用来创建子类对象，静态方法\_\_new\_\_用来创建实例，再调用\_\_init\_\_初始化实例

### \_\_str\_\_ vs \_\_repr\_\_
- 默认的实现没有任何作用
- \_\_str\_\_的目标是对象信息的可读性，\_\_repr\_\_目标是对象信息的唯一性
- 如果没有重写\_\_str\_\_，则默认调用\_\_str\_\_时，会调用\_\_repr\_\_

### \_\_slot\_\_
如果类 C 拥有\_\_slot\_\_属性，那么它就没有\_\_dict\_\_属性，即 C 的实例不能绑定额外的属性。省去了\_\_dict\_\_属性，有利于节省内存

## 新式类 vs 经典类
- 新式类继承了 object，拥有更多的默认方法
- MRO（方法解析顺序）：经典类使用从左到右、深度优先顺序查找；新式类使用从左到右、广度优先顺序遍历

## descriptor
- 如果在对象中定义了\_\_get\_\_、\_\_set\_\_、\_\_del\_\_，就说这个对象是一个 descriptor 对象，可以把这个对象赋值给其它属性
- 如果需要被查找的属性是一个定义了 descriptor 协议方法的对象，那么 python 就不会按照默认的查找方式，而是调用 descriptor 协议中定义的方法去做处理

## 垃圾回收机制
Python GC主要使用引用计数来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”解决容器对象可能产生的循环引用问题，通过“分代回收”以空间换时间的方法提高垃圾回收效率