# GC
## Full GC 触发条件
1. System.gc()方法的调用
System.gc()相当于调用Runtime.getRuntime().gc()，只是建议Java虚拟机对此部分内存进行回收，但是不一定会发生GC
2. 老年代空间不足
3. 永生代空间不足
4. CMS GC时出现promotion failed和concurrent mode failure
5. 统计得到的Minor GC晋升到老生代的平均大小大于老年代的剩余空间
6. 堆中分配很大的对象

## 垃圾回收的最佳实践
- 手动调用System.gc()进行垃圾回收
- 建议不要用finalize()方法写任何代码

## 吞吐量 vs 响应时间
- 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验
- 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务

## 垃圾收集器对比
| 名称 | 运行方式 | 算法 | 回收区 | 目标 | 适用场景 |
| :----- | :----- | :----- | :----- | :----- | :----- |
| Serial | 串行 | 复制算法 | 新生代 | 响应速度优先 | 单CPU环境下的Client模式 |
| Parallel Scavenge | 并行 | 复制算法 | 新生代 | 吞吐量优先 | 在后台运算而不需要太多交互的任务 |
| CMS | 并发 | 标记-清除算法 | 老生代 | 响应速度优先 | 集中在互联网站或B/S系统服务端上的Java应用 |
| G1 | 并发 | 标记-整理 + 复制算法 | 新生代和老生代 | 响应速度优先 | 面向服务端应用，将来替换CMS |

## CMS 垃圾收集器工作过程
![](http://osbdeld5c.bkt.clouddn.com/18-3-29/31956834.jpg)