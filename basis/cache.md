# 缓存
## 数据一致性
### 主从数据库一致性
- 写请求在主从数据库同步之后再返回；会增加延时
- 数据库中间件，CUD 路由到主库，并记录 key；在 R 时，如果在经验主从同步时间窗口内，则路由到主库，否则路由到从库
- 使用 cache 替代中间件，一样的操作，但是成本较低

### 数据库缓存一致性（缓存读取与更新）
- 首先尝试从缓存读取，读到数据则直接返回；如果读不到，就读数据库，并将数据会写到缓存，并返回
- 更新数据
 - 先更新数据库，然后把缓存里对应的数据失效掉（删掉）；会有一小段时间的不一致，可设置过期时间，经常更新
 - 先更新缓存，再同步到数据库；读缓存无数据，然后读数据库，在准备写到缓存时，写线程更新了缓存，此时读线程会把旧数据覆盖到缓存，可维护数据版本，读线程更新缓存时，发现版本不一致则停止更新缓存

### 分布式缓存一致性
- 分布式缓存可以丢失，但是不能出错，对于新增的缓存，可以不同步；删除、修改的缓存，可以通知其他缓存直接删除对应数据
- 通过 zookeeper 锁实现一致性
- redis 使用一致性 hash，只需一份缓存

## CPU 缓存一致性（MESI）
### cache 状态
- modify：当前 CPU cache 拥有最新数据（最新的 cache line），其他 CPU 拥有失效数据（cache line 的状态是 invalid），虽然当前 CPU 中的数据和主存是不一致的，但是以当前 CPU 的数据为准
- exclusive：只有当前 CPU 中有数据，其他 CPU 中没有该数据，当前 CPU 的数据和主存中的数据是一致的
- shared：当前 CPU 和其他 CPU 中都有共同数据，并且和主存中的数据一致
- invalid：当前 CPU 中的数据失效，数据应该从主存中获取，其他 CPU 中可能有数据也可能无数据，当前 CPU 中的数据和主存被认为是不一致的。对于 invalid 而言，在 MESI 协议中采取的是写失效（当一个 CPU 修改了数据，如果其他 CPU 有该数据，则通知其为无效）

### cache 操作
- local read（LR）：读本地 cache 中的数据
- local write（LW）：将数据写到本地 cache
- remote read（RR）：读取主存中的数据
- remote write（RW）：将数据写到主存

### 缓存伪共享问题
- 问题：不同的 cpu 操作相同的缓存行，导致缓存行频繁修改，影响性能
- 解决：可使用缓存行填充，将变量填充到 64 字节，使其单独占用一个缓存行，避免伪共享

## 分布式锁实现
### 基于数据库的锁
#### 基于数据库表
创建一个锁表，对锁定字段做唯一性约束，保证只有一个线程成功插入

#### 基于排它锁
利用 select for update 时添加的排它锁实现加锁，解锁时只需要 commit

### 基于缓存的锁
#### Redlock 算法
设置 N 个 redis 节点形成集群，客户端按序并按相同 kv 获取 N 个锁，会设置超时时间（远小于锁过期时间），若在锁超时之前获得了大部分节点的锁，则成功；否则依此删除所有节点的锁

##### 问题
- 锁超时：客户端记录锁的可用时间，在超时时放弃锁
- 重启问题（节点重启，锁信息未持久化导致丢失）：延迟重启，在所有节点锁超时后再重启
- 多客户端竞争：参考 raft，冲突后客户端在随机时间内开始重新获取

### 基于 Zookeeper 的锁
文件夹下存放锁文件，最小序号的文件获得锁；否则等待最小序号释放锁；客户端与 zookeeper 通过 session 保持连接

## 如何避免缓存穿透
- 缓存空对象：对查询结果为空的对象也进行缓存；适合命中率不高，但可能被频繁更新的数据
- 单独过滤处理：对所有可能对应数据为空的key进行统一的存放，并在请求前做拦截；适合命中不高，但是更新不频繁的数据