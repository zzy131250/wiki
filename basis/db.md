# 数据库
## 关于范式的解释
[知乎回答](https://www.zhihu.com/question/24696366/answer/29189700)

## 聚集索引 vs 非聚集索引
- 聚集索引：索引的逻辑顺序决定数据的物理顺序
- 非聚集索引：索引的逻辑顺序与数据的物理顺序不同

## 覆盖索引
索引表包含满足查询的所有数据，不必回查数据表

## B 树索引 vs B+ 树索引
- 相同点：解决主存与磁盘速度差异，用更多的计算减少磁盘访问，减小树的深度
- 不同点：B+ 树解决了 B 树在提高了磁盘 IO 性能的同时并没有解决元素遍历的效率低下的问题

## 数据库事务性质（ACID）
- 原子性：事务的更新操作必须作为一个整体，要么全部成功完成，要么全部失败
- 一致性：事务的成功完成将数据库从一个一致状态转变到另一个一致状态
- 隔离性：即使多个事务并发执行，看上去要像每个成功事务按串行调度执行一样
- 持久性：一旦事务提交，那么它对数据所作的修改将是持久的，无论发生何种机器和系统故障

## drop vs delete vs truncate
- delete 和 truncate 只删除表的数据不删除表的结构
- 速度一般来说: drop > truncate > delete
- delete 语句是 dml，这个操作会放到 rollback segment 中，事务提交之后才生效；truncate、drop 是 ddl，操作立即生效，不能回滚

## 数据库事务隔离级别原理
![](http://osbdeld5c.bkt.clouddn.com/18-3-31/1597284.jpg)

## 数据库主从同步对比
![](http://osbdeld5c.bkt.clouddn.com/18-3-31/16674531.jpg)

## Copy-On-Write vs MVCC
- Copy-On-Write：在写入时新建一个块，写入新块中，再替换原有块；适合读多写少的情景，满足最终一致性
- MVCC：数据库的乐观锁实现，类似于 Copy-On-Write，当有读事务访问一个旧值时，修改类事务就会 copy 出来一个副本进行修改，保证读写不会冲突，而且不会锁住流程

## Mysql InnoDB vs MyIASM
| | InnoDB | MyIASM |
| ----- | ----- | ----- |
| 事务 | 事务安全 | 非事务安全 |
| 锁 | 行级锁 | 表级锁 |
| 全文索引 | 不支持 | 支持 |
| 效率 | 低 | 高 |

## Mysql InnoDB 锁
- 表锁
 - 读锁：LOCK TABLE table READ；用读锁锁表，会阻塞其他事务修改表数据
 - 写锁：LOCK TABLE table WRITE；用写锁锁表，会阻塞其他事务读和写
- 行锁：给索引项加锁，若无索引条件，则使用表锁
 - 共享锁：一个事务对一行的共享只读锁。SELECT ... LOCK IN SHARE MODE;
 - 排它锁：一个事务对一行的排他读写锁。SELECT ... FOR UPDATE;
- 意向锁：在加行锁之前，先加表意向锁。之后其他事务想要申请表锁时，不用遍历每行查看是否有行锁

## Mysql InnoDB 可重复读级别可以避免某些幻读
### 快照读 vs 当前读
- 快照读：读各个事务独立的数据，但不一定是最新数据
- 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前最新的数据

### 避免范围幻读
- 通过 MVCC 避免快照读的幻读
 - 在 undo log 中记录事务版本号，各个事务都读取对应版本的数据
- 通过 Next-Key 锁避免当前读的范围幻读

#### Next-Key 锁
Next-Key 锁是行锁和 GAP （间隙锁）的合并。行锁防止别的事务修改或删除，GAP 锁防止别的事务新增

#### GAP 间隙锁
事务更新某条数据时，在该行加入行锁，同时在两边的区间加上 GAP 锁，如果使用的是没有索引的字段，那么会给全表加入 GAP 锁

## 数据一致性
### 主从数据库一致性
- 写请求在主从数据库同步之后再返回；会增加延时
- 数据库中间件，CUD 路由到主库，并记录 key；在 R 时，如果在经验主从同步时间窗口内，则路由到主库，否则路由到从库
- 使用 cache 替代中间件，一样的操作，但是成本较低

### 数据库缓存一致性（缓存读取与更新）
- 首先尝试从缓存读取，读到数据则直接返回；如果读不到，就读数据库，并将数据会写到缓存，并返回
- 更新数据
 - 先更新数据库，然后把缓存里对应的数据失效掉（删掉）；会有一小段时间的不一致，可设置过期时间，经常更新
 - 先更新缓存，再同步到数据库；读缓存无数据，然后读数据库，在准备写到缓存时，写线程更新了缓存，此时读线程会把旧数据覆盖到缓存，可维护数据版本，读线程更新缓存时，发现版本不一致则停止更新缓存

### 分布式缓存一致性
- 分布式缓存可以丢失，但是不能出错，对于新增的缓存，可以不同步；删除、修改的缓存，可以通知其他缓存直接删除对应数据
- 通过 zookeeper 锁实现一致性
- redis 使用一致性 hash，只需一份缓存

### CPU 缓存一致性（MESI）
#### cache 状态
- modify：当前 CPU cache 拥有最新数据（最新的 cache line），其他 CPU 拥有失效数据（cache line 的状态是 invalid），虽然当前 CPU 中的数据和主存是不一致的，但是以当前 CPU 的数据为准
- exclusive：只有当前 CPU 中有数据，其他 CPU 中没有该数据，当前 CPU 的数据和主存中的数据是一致的
- shared：当前 CPU 和其他 CPU 中都有共同数据，并且和主存中的数据一致
- invalid：当前 CPU 中的数据失效，数据应该从主存中获取，其他 CPU 中可能有数据也可能无数据，当前 CPU 中的数据和主存被认为是不一致的。对于 invalid 而言，在 MESI 协议中采取的是写失效（当一个 CPU 修改了数据，如果其他 CPU 有该数据，则通知其为无效）

#### cache 操作
- local read（LR）：读本地 cache 中的数据
- local write（LW）：将数据写到本地 cache
- remote read（RR）：读取主存中的数据
- remote write（RW）：将数据写到主存

#### 缓存伪共享问题
- 问题：不同的 cpu 操作相同的缓存行，导致缓存行频繁修改，影响性能
- 解决：可使用缓存行填充，将变量填充到 64 字节，使其单独占用一个缓存行，避免伪共享

## 分布式锁实现
### 基于数据库的锁
#### 基于数据库表
创建一个锁表，对锁定字段做唯一性约束，保证只有一个线程成功插入

#### 基于排它锁
利用 select for update 时添加的排它锁实现加锁，解锁时只需要 commit

### 基于缓存的锁
#### Redlock 算法
设置 N 个 redis 节点形成集群，客户端按序并按相同 kv 获取 N 个锁，会设置超时时间（远小于锁过期时间），若在锁超时之前获得了大部分节点的锁，则成功；否则依此删除所有节点的锁

##### 问题
- 锁超时：客户端记录锁的可用时间，在超时时放弃锁
- 重启问题（节点重启，锁信息未持久化导致丢失）：延迟重启，在所有节点锁超时后再重启
- 多客户端竞争：参考 raft，冲突后客户端在随机时间内开始重新获取

### 基于 Zookeeper 的锁
文件夹下存放锁文件，最小序号的文件获得锁；否则等待最小序号释放锁；客户端与 zookeeper 通过 session 保持连接

## 如何避免缓存穿透
- 缓存空对象：对查询结果为空的对象也进行缓存；适合命中率不高，但可能被频繁更新的数据
- 单独过滤处理：对所有可能对应数据为空的key进行统一的存放，并在请求前做拦截；适合命中不高，但是更新不频繁的数据