# 数据库
## 关于范式的解释
[知乎回答](https://www.zhihu.com/question/24696366/answer/29189700)

## 索引分类
- 普通索引：最基本的索引，没有任何限制
- 唯一索引：索引列的值必须唯一，但允许有空值
- 主键索引：一种特殊的唯一索引，不允许有空值
- 辅助索引：叶子节点存放了主键索引的值，再根据主键索引获取数据
- 聚集索引：索引的逻辑顺序决定数据的物理顺序，如主键索引
- 非聚集索引：索引的逻辑顺序与数据的物理顺序不同

## 覆盖索引
索引表包含满足查询的所有数据，不必回查数据表

## B 树索引 vs B+ 树索引
- 相同点：解决主存与磁盘速度差异，用更多的计算减少磁盘访问，减小树的深度
- 不同点：B+ 树解决了 B 树在提高了磁盘 IO 性能的同时并没有解决元素遍历的效率低下的问题

## 数据库事务性质（ACID）
- 原子性：事务的更新操作必须作为一个整体，要么全部成功完成，要么全部失败
- 一致性：事务的成功完成将数据库从一个一致状态转变到另一个一致状态
- 隔离性：即使多个事务并发执行，看上去要像每个成功事务按串行调度执行一样
- 持久性：一旦事务提交，那么它对数据所作的修改将是持久的，无论发生何种机器和系统故障

## 数据库事务隔离级别原理
![](http://zia-wiki.oss-cn-hangzhou.aliyuncs.com/18-10-27/20501610.jpg)

## drop vs delete vs truncate
- delete 和 truncate 只删除表的数据不删除表的结构
- 速度一般来说: drop > truncate > delete
- delete 语句是 dml，这个操作会放到 rollback segment 中，事务提交之后才生效；truncate、drop 是 ddl，操作立即生效，不能回滚

## 数据库主从同步对比
![](http://zia-wiki.oss-cn-hangzhou.aliyuncs.com/18-10-27/27150369.jpg)

## Copy-On-Write vs MVCC
- Copy-On-Write：在写入时新建一个块，写入新块中，再替换原有块；适合读多写少的情景，满足最终一致性
- MVCC：数据库的乐观锁实现，类似于 Copy-On-Write，当有读事务访问一个旧值时，修改类事务就会 copy 出来一个副本进行修改，保证读写不会冲突，而且不会锁住流程

## Mysql InnoDB vs MyIASM
| | InnoDB | MyIASM |
| ----- | ----- | ----- |
| 事务 | 事务安全 | 非事务安全 |
| 锁 | 行级锁 | 表级锁 |
| 全文索引 | 不支持 | 支持 |
| 效率 | 低 | 高 |

## Mysql 索引条件下推（Mysql 5.6 引入）
将可以利用但不能完全匹配的 where 条件在存储引擎一侧对索引进行筛选（将 where 条件作用于索引上），而不是将所有 index access 的结果取出放在 server 端进行 where 筛选。

### 关闭 ICP（Index Condition Pushdown）
索引仅仅作为 data access 使用
![](https://zia-wiki.oss-cn-hangzhou.aliyuncs.com/19-6-16/39831041.jpg)

### 开启 ICP
存储引擎端首先用 where 条件过滤不符合的索引项，然后再用索引做 data access，被索引条件过滤掉的索引及数据不必读取，也不会返回 server 端
![](https://zia-wiki.oss-cn-hangzhou.aliyuncs.com/19-6-16/33974534.jpg)

### ICP 注意事项
- ICP 只能用于二级索引，不能用于主索引
- 若 where 条件的字段不在索引中，则无法使用 ICP
- ICP 的加速效果取决于在存储引擎内通过 ICP 筛选掉的数据的比例

## Mysql 事务日志
Mysql通过日志来保证事务的特性。
- Redo Log
  - 实现了事务的持久性
  - 记录每条数据在操作后的状态，在事务提交之前进行持久化，用于事务恢复
- Undo Log
  - 实现事务的原子性和 MVCC
  - 记录每条数据在操作前的状态，可用于事务回滚
  - 不是物理恢复数据，而是逻辑恢复数据；即对于 insert 语句，记录的是 delete，对于 update 也记录的是相反的 update

## Mysql InnoDB 锁
- 表锁
 - 读锁：LOCK TABLE table READ；用读锁锁表，会阻塞其他事务修改表数据
 - 写锁：LOCK TABLE table WRITE；用写锁锁表，会阻塞其他事务读和写
- 行锁：给索引项加锁，若无索引条件，则使用表锁
 - 共享锁：一个事务对一行的共享只读锁。SELECT ... LOCK IN SHARE MODE;
 - 排它锁：一个事务对一行的排他读写锁。SELECT ... FOR UPDATE;
- 意向锁：在加行锁之前，先加表意向锁。之后其他事务想要申请表锁时，不用遍历每行查看是否有行锁

## Mysql InnoDB 可重复读级别可以避免某些幻读
### 快照读 vs 当前读
- 快照读：读各个事务独立的数据，但不一定是最新数据
- 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前最新的数据

### 避免范围幻读
- 通过 MVCC 避免快照读的幻读
 - 在 undo log 中记录事务版本号，各个事务都读取对应版本的数据
- 通过 Next-Key 锁避免当前读的范围幻读

#### Next-Key 锁
Next-Key 锁是行锁和 GAP （间隙锁）的合并。行锁防止别的事务修改或删除，GAP 锁防止别的事务新增

#### GAP 间隙锁
事务更新某条数据时，在该行加入行锁，同时在两边的区间加上 GAP 锁，如果使用的是没有索引的字段，那么会给全表加入 GAP 锁